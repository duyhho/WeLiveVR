//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Xarm
{
    [Serializable]
    public class MoveVelocityRequest : Message
    {
        public const string k_RosMessageName = "xarm_msgs/MoveVelocity";
        public override string RosMessageName => k_RosMessageName;

        //  request: command specification for velocity executions.
        //  Units:
        // 	joint space/angles: radian/s
        // 	Cartesian space: mm/s, radian/s.
        //  velocities: the velocity list of the joints/tcp
        //    For velo_move_joint_timed service: [joint1_velocity, ..., joint7_velocity]
        //    For velo_move_line_timed service: [x_velocity, y_velocity, z_velocity, rx_velocity, ry_velocity, rz_velocity (axis-angle)]
        public float[] speeds;
        //  is_sync: this is special for velo_move_joint service, meaning whether all joints accelerate and decelerate synchronously, true for yes, false for no.
        //  avaiable for service velo_move_joint_timed
        public bool is_sync;
        //  is_tool_coord: this is special for velo_move_line service, meaning whether motion is in tool coordinate(true) or not(false)
        //  avaiable for service velo_move_line_timed
        public bool is_tool_coord;
        //  the maximum duration of the speed, over this time will automatically set the speed to 0
        //    duration > 0: seconds, indicates the maximum number of seconds that this speed can be maintained
        //    duration == 0: always effective, will not stop automativally
        //    duration < 0: default value, only used to be compatible with the old protocol, equivalent to 0
        //  avaiable for firmware_version >= 1.8.0
        public float duration;

        public MoveVelocityRequest()
        {
            this.speeds = new float[0];
            this.is_sync = false;
            this.is_tool_coord = false;
            this.duration = 0.0f;
        }

        public MoveVelocityRequest(float[] speeds, bool is_sync, bool is_tool_coord, float duration)
        {
            this.speeds = speeds;
            this.is_sync = is_sync;
            this.is_tool_coord = is_tool_coord;
            this.duration = duration;
        }

        public static MoveVelocityRequest Deserialize(MessageDeserializer deserializer) => new MoveVelocityRequest(deserializer);

        private MoveVelocityRequest(MessageDeserializer deserializer)
        {
            deserializer.Read(out this.speeds, sizeof(float), deserializer.ReadLength());
            deserializer.Read(out this.is_sync);
            deserializer.Read(out this.is_tool_coord);
            deserializer.Read(out this.duration);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.WriteLength(this.speeds);
            serializer.Write(this.speeds);
            serializer.Write(this.is_sync);
            serializer.Write(this.is_tool_coord);
            serializer.Write(this.duration);
        }

        public override string ToString()
        {
            return "MoveVelocityRequest: " +
            "\nspeeds: " + System.String.Join(", ", speeds.ToList()) +
            "\nis_sync: " + is_sync.ToString() +
            "\nis_tool_coord: " + is_tool_coord.ToString() +
            "\nduration: " + duration.ToString();
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
